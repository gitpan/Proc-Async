<html><head><title>Proc::Async</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >

<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
BODY {
  background: white;
  color: black;
  font-family: arial,sans-serif;
  margin: 0;
  padding: 1ex;
}

A:link, A:visited {
  background: transparent;
  color: #006699;
}

A[href="#POD_ERRORS"] {
  background: transparent;
  color: #FF0000;
}

DIV {
  border-width: 0;
}

DT {
  margin-top: 1em;
  margin-left: 1em;
}

.pod { margin-right: 20ex; }

.pod PRE     {
  background: #eeeeee;
  border: 1px solid #888888;
  color: black;
  padding: 1em;
  white-space: pre;
}

.pod H1      {
  background: transparent;
  color: #006699;
  font-size: large;
}

.pod H1 A { text-decoration: none; }
.pod H2 A { text-decoration: none; }
.pod H3 A { text-decoration: none; }
.pod H4 A { text-decoration: none; }

.pod H2      {
  background: transparent;
  color: #006699;
  font-size: medium;
}

.pod H3      {
  background: transparent;
  color: #006699;
  font-size: medium;
  font-style: italic;
}

.pod H4      {
  background: transparent;
  color: #006699;
  font-size: medium;
  font-weight: normal;
}

.pod IMG     {
  vertical-align: top;
}

.pod .toc A  {
  text-decoration: none;
}

.pod .toc LI {
  line-height: 1.2em;
  list-style-type: none;
}

  /*]]>*/-->
</style>


</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Sun May 26 12:23:13 2013 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#start(%24args)_or_start(%40args)'>start($args) or start(@args)</a>
    <li class='indexItem indexItem2'><a href='#status(%24jobid)'>status($jobid)</a>
    <li class='indexItem indexItem2'><a href='#is_finished(%24jobid)'>is_finished($jobid)</a>
    <li class='indexItem indexItem2'><a href='#signal(%24jobid_%5B%2C%24signal%5D)'>signal($jobid [,$signal])</a>
    <li class='indexItem indexItem2'><a href='#result_list(%24jobid)'>result_list($jobid)</a>
    <li class='indexItem indexItem2'><a href='#result(%24jobid%2C_%24file)'>result($jobid, $file)</a>
    <li class='indexItem indexItem2'><a href='#stdout(%24jobid)'>stdout($jobid)</a>
    <li class='indexItem indexItem2'><a href='#stderr(%24jobid)'>stderr($jobid)</a>
    <li class='indexItem indexItem2'><a href='#working_dir(%24jobid)'>working_dir($jobid)</a>
    <li class='indexItem indexItem2'><a href='#clean(%24jobid)'>clean($jobid)</a>
    <li class='indexItem indexItem2'><a href='#get_configuration(%24jobid)'>get_configuration($jobid)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ADDITIONAL_FILES'>ADDITIONAL FILES</a>
  <ul   class='indexList indexList2'>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#scripts%2Fprocasync'>scripts/procasync</a>
      <li class='indexItem indexItem3'><a href='#examples%2FREADME'>examples/README</a>
      <li class='indexItem indexItem3'><a href='#t%2Fdata%2Fextester'>t/data/extester</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Missing_features'>Missing features</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Proc::Async - Running and monitoring processes asynchronously</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.1.3</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>   use Proc::Async;

   # start an external program
   $jobid = Proc::Async-&#62;start (&#39;blastx&#39;, &#39;-query&#39;, &#39;/data/my.seq&#39;, &#39;-out&#39;, &#39;blastout&#39;);

   # later, usually from another program (or in another time),
   # investigate what is the external program doing
   if (Proc::Async-&#62;is_finished ($jobid)) {
      @files = Proc::Async-&#62;result_list ($jobid);
      foreach my $file (@files) {
         print Proc::Async-&#62;result ($file);
      }
      print Proc::Async-&#62;stdout();
      print Proc::Async-&#62;stderr();
   }

   $status = Proc::Async-&#62;status ($jobid);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module can execute an external process, monitor its state, get its results and, if needed, kill it prematurely and remove its results. There are, of course, many modules that cover similar functionality, including functions directly built-in in Perl. So why to have this module, at all? The main feature is hidden in the second part of the module name, the word <b>Async</b>. The individual methods (to execute, to monitor, to get results, etc.) can be called (almost) independently from each other, from separate Perl programs, and there may be any delay between them.</p>

<p>It focuses mainly on invoking external programs from the CGI scripts in the web applications. Here is a typical scenario: Your CGI script starts an external program which may take some time before it finishes. The CGI scripts does not wait for it and returns back, remembering (e.g. in a form of a hidden variable in the returned HTML page) the only thing, the ID of the just started job (a <code>jobID</code>). Meanwhile, the invoked external program has been <i>demonized</i> (it became a daemon process, a process nobody waits for). Now you have another CGI script that can use the remembered <code>jobID</code> to monitor status and get results of the previously started process.</p>

<p>The core functionality, the demonization, is done by the module <code>Proc::Daemon</code>. If you plan to write a single program that starts a daemon process and waits for it, then you may need just the <code>Proc::Daemon</code> module. But if you wish to split individual calls into two or more programs then the <code>Proc::Async</code> may be your choice.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>All methods of this module are <i>class</i> methods, there is no <code>new</code> instance constructor. It does not make much sense to have an instance if you wish to use it from a separate program, does it? The communication between individual calls is done in a temporary directory (as it is explained later in this documentation but it is not important for the module usage).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="start($args)_or_start(@args)"
>start($args) <i>or</i> start(@args)</a></h2>

<p>This method starts an external program, makes a daemon process from it, does not wait for its completion and returns a token, a job ID. This token will be used as an argument in all other methods. Therefore, there is no sense to call any of the other methods without calling the <code>start()</code> first.</p>

<p><code>$args</code> is an arrayref with the full command-line (including the external program name). Or, it can be given as a normal list <code>@args</code>.</p>

<p>For example:</p>

<pre>   my $jobid = Proc::Async-&#62;start (qw{ wget -O cpan.index.html http://search.cpan.org/index.html });</pre>

<p>or</p>

<pre>   my $jobid = Proc::Async-&#62;start ( [qw{ wget -O cpan.index.html http://search.cpan.org/index.html }] );</pre>

<p>For each job, this method creates a temporary directory (within your system temporary directory, which is, on Unix system, usually <code>/tmp</code>) and change there (<code>chdir</code>) before executing the wanted external program. Keep this directory change in mind if your external programs are in the same directory as your Perl program that invokes them. You can use, for example, the <code>FindBin</code> module to locate them correctly:</p>

<pre>   use FindBin qw($Bin);
   ...
   my @args = (&#34;$Bin/my-external-program&#34;, ....);
   $jobid = Proc::Async-&#62;start (\@args);</pre>

<p>If you need to access this job directory (in case that you need more than provided by the methods of this module), use the method <code>working_dir()</code> to get its path and name.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="status($jobid)"
>status($jobid)</a></h2>

<p>In scalar context, it returns status of the given process (given by its $jobid). The status is expressed by a plain text using the following constants:</p>

<pre>   use constant {
       STATUS_UNKNOWN     =&#62; &#39;unknown&#39;,
       STATUS_CREATED     =&#62; &#39;created&#39;,
       STATUS_RUNNING     =&#62; &#39;running&#39;,
       STATUS_COMPLETED   =&#62; &#39;completed&#39;,
       STATUS_TERM_BY_REQ =&#62; &#39;terminated by request&#39;,
       STATUS_TERM_BY_ERR =&#62; &#39;terminated by error&#39;,
   };</pre>

<p>In array context, it additionally returns (optional) details of the status. There can be zero to more details accompanying the status, e.g. the exit code, or the signal number that caused the process to die. The details are in plain text, no constants used. For example:</p>

<pre>   $jobid = Proc::Async-&#62;start (&#39;date&#39;);
   @status = Proc::Async-&#62;status ($jobid);
   print join (&#34;\n&#34;, @status);</pre>

<p>will print:</p>

<pre>   running
   started at Sat May 18 09:35:27 2013</pre>

<p>or</p>

<pre>   $jobid = Proc::Async-&#62;start (&#39;sleep&#39;, 5);
   ...
   @status = Proc::Async-&#62;status ($jobid);
   print join (&#34;\n&#34;, @status);</pre>

<p>will print:</p>

<pre>   completed
   exit code 0
   completed at Sat May 18 09:45:12 2013
   elapsed time 5 seconds</pre>

<p>or, a case when the started job was killed:</p>

<pre>   $jobid = Proc::Async-&#62;start (&#39;sleep&#39;, 60);
   Proc::Async-&#62;signal ($jobid, 9);
   @status = Proc::Async-&#62;status ($jobid);
   print join (&#34;\n&#34;, @status);</pre>

<p>will print:</p>

<pre>   terminated by request
   terminated by signal 9
   without coredump
   terminated at Sat May 18 09:41:56 2013
   elapsed time 0 seconds</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_finished($jobid)"
>is_finished($jobid)</a></h2>

<p>A convenient method that returns true if the status of the job indicates that the external program had finished (well or badly). Or false if not. Which includes the case when the state is unknown.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="signal($jobid_[,$signal])"
>signal($jobid [,$signal])</a></h2>

<p>It sends a signal to the given job (given by the <code>$jobid</code>). <code>$signal</code> is a positive integer between 1 and 64. Default is 9 which means the KILL signal. The available signals are the ones listed out by <code>kill -l</code> on your system.</p>

<p>It returns true on success, zero on failure (no such job, no such process). It can also croak if the <code>$signal</code> is invalid.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="result_list($jobid)"
>result_list($jobid)</a></h2>

<p>It returns a list of (some) filenames that exist in the job directory that is specified by the given $jobid. The filenames are relative to this job directory, and they may include subdirectories if there are subdirectories within this job directory (it all depends what your external program created there). For example:</p>

<pre>   $jobid = Proc::Async-&#62;start (qw{ wget -o log.file -O output.file http://www.perl.org/index.html });
   ...
   @files = Proc::Async-&#62;result_list ($jobid);
   print join (&#34;\n&#34;, @files);</pre>

<p>prints:</p>

<pre>   output.file
   log.file</pre>

<p>The names of the files returned by the <code>result_list()</code> can be used in the method <code>result()</code> in order to get the file content.</p>

<p>If the given $jobid does not represent an existing (and readable) directory, it returns an empty list (without croaking).</p>

<p>If the external program created new files inside new directories, the <code>result_list()</code> returns names of these files, too. In other words, it returns names of all files found within the job directory (however deep in sub-directories), except special files (see the next paragraph) and empty sub-directories.</p>

<p>There are also files with the special names, as defined by the following constants:</p>

<pre>   use constant STDOUT_FILE =&#62; &#39;___proc_async_stdout___&#39;;
   use constant STDERR_FILE =&#62; &#39;___proc_async_stderr___&#39;;
   use constant CONFIG_FILE =&#62; &#39;___proc_async_status.cfg&#39;;</pre>

<p>These files contain standard streams of the external programs (their content can be fetched by the methods <code>stdout()</code> and <code>stderr()</code>) and internal information about the status of the executed program.</p>

<p>Another example: If the contents of a job directory is the following:</p>

<pre>   ___proc_async_stdout___
   ___proc_async_stderr___
   ___proc_async_status.cfg
   a.file
   a.dir/
      file1
      file2
      b.dir/
         file3
   empty.dir/</pre>

<p>then the returned list will look like this:</p>

<pre>   (&#39;a.file&#39;,
    &#39;a.dir/file1&#39;,
    &#39;a.dir/file2&#39;,
    &#39;b.dir/file3&#39;)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="result($jobid,_$file)"
>result($jobid, $file)</a></h2>

<p>It returns the content of the given $file from the job given by $jobid. The $file is a relative filename; must be one of those returned by method <code>result_list()</code>. It returns undef if the $file does not exist (or if it does not exist in the list returned by <code>result_list()</code>).</p>

<p>For getting content of the standard stream, use the following methods:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="stdout($jobid)"
>stdout($jobid)</a></h2>

<p>It returns the content of the STDOUT from the job given by $jobid. It may be an empty string if the job did not produce any STDOUT, or if the job does not exist anymore.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="stderr($jobid)"
>stderr($jobid)</a></h2>

<p>It returns the content of the STDERR from the job given by $jobid. It may be an empty string if the job did not produce any STDERR, or if the job does not exist anymore.</p>

<p>If you execute an external program that cannot be found you will find an error message about it here, as well:</p>

<pre>   my $jobid = Proc::Async-&#62;start (&#39;a-bad-program&#39;);
   ...
   print join (&#34;\n&#34;, Proc::Async-&#62;status ($jobid);

      terminated by error
      exit code 2
      completed at Sat May 18 11:02:04 2013
      elapsed time 0 seconds

   print Proc::Async-&#62;stderr();

      Can&#39;t exec &#34;a-bad-program&#34;: No such file or directory at lib/Proc/Async.pm line 148.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="working_dir($jobid)"
>working_dir($jobid)</a></h2>

<p>It returns the name of the working directory for the given $jobid. Or undef if such working directory does not exist.</p>

<p>You may notice that the $jobid looks like a name of a working directory. Actually, in the current implementation, it is, indeed, the same. But it may change in the future. Therefore, better use this method and do not rely on such sameness.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="clean($jobid)"
>clean($jobid)</a></h2>

<p>It deletes all files belonging to the given job, including its job directory. It returns the number of file successfully deleted. If you ask for a status of the job after being cleaned up, you get <code>STATUS_UNKNOWN</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_configuration($jobid)"
>get_configuration($jobid)</a></h2>

<p>Use this method only if you wish to look at the internals (for example to get exact starting and ending time of a job). It creates a configuration (an instance of <code>Proc::Async::Config</code>) and fills it from the configuration file (if such file exists) for the given job. It returns a two-element array, the first element being a configuration instance, the second element the file name where the configuration was filled from:</p>

<pre>   my $jobid = Proc::Async-&#62;start (&#39;date&#39;, &#39;-u&#39;);
   ...
   my ($cfg, $cfgfile) = Proc::Async-&#62;get_configuration ($jobid);
   foreach my $name ($cfg-&#62;param) {
      foreach my $value ($cfg-&#62;param ($name)) {
          print STDOUT &#34;$name=$value\n&#34;;
      }
   }</pre>

<p>will print:</p>

<pre>   job.arg=date
   job.arg=-u
   job.ended=1368865570
   job.id=/tmp/q74Bgd8mXX
   job.pid=22273
   job.started=1368865570
   job.status=completed
   job.status.detail=exit code 0
   job.status.detail=completed at Sat May 18 11:26:10 2013
   job.status.detail=elapsed time 0 seconds</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ADDITIONAL_FILES"
>ADDITIONAL FILES</a></h1>

<p>The module distribution has several example and helping files (which are not installed when the module is fetched by the <code>cpan</code> or <code>cpanm</code>).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="scripts/procasync"
>scripts/procasync</a></h3>

<p>It is a command-line oriented script that can invoke any of the functionality of this module. Its purpose is to test the module and, perhaps more importantly, to show how to use the module&#39;s methods. Otherwise, it does not make much sense (that is why it is not normally installed).</p>

<p>It has its own (but only short) documentation:</p>

<pre>   scripts/procasync -help</pre>

<p>or</p>

<pre>   perldoc scripts/procasync</pre>

<p>Some examples are:</p>

<pre>   scripts/procasync -start date
   scripts/procasync -start &#39;date -u&#39;
   scripts/procasync -start &#39;sleep 100&#39;</pre>

<p>The <code>-start</code> arguments can be repeated if its arguments have spaces:</p>

<pre>   scripts/procasync -start cat -start &#39;/data/filename with spaces&#39;</pre>

<p>All lines above print a job ID that must be used in a consequent usage:</p>

<pre>   scripts/procasync -jobid /tmp/hBsXcrafhn -status
   scripts/procasync -jobid /tmp/hBsXcrafhn -stdout -stderr -rlist
   scripts/procasync -jobid /tmp/hBsXcrafhn -wdir
   ...etc...</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="examples/README"
>examples/README</a></h3>

<p>Because this module is focused mainly on its usage within CGI scripts, there is an example of a simple web application. The <code>README</code> file explains how to install it and run it from your web server. Here <a href="http://sites.google.com/site/martinsenger/extester-screenshot.png" class="podlinkurl"
>http://sites.google.com/site/martinsenger/extester-screenshot.png</a> is its screenshot.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="t/data/extester"
>t/data/extester</a></h3>

<p>This script can be used for testing this module (as it is used in the regular Perl tests and in the web application mentioned above). It can be invoked as an external program and, depending on its command line arguments, it creates some standard and/or standard error streams, exits with the specified exit code, etc. It has its own documentation:</p>

<pre>   perldoc t/data/extester</pre>

<p>An example of its command-line:</p>

<pre>   extester -stdout an-out -stderr an-err -exit 5 -create a.tmp=5 few/new/dirs/b.tmp=3 an/empty/dir/=0</pre>

<p>which writes given short texts into stdout and stderr, creates two files (<code>a.tmp</code> and <code>b.tmp</code>, the latter one together with the given sub-directories hierarchy) and it exits with exit code 5.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Please report any bugs or feature requests to <a href="http://github.com/msenger/Proc-Async/issues" class="podlinkurl"
>http://github.com/msenger/Proc-Async/issues</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Missing_features"
>Missing features</a></h2>

<dl>
<dt><a name="Standard_input"
>Standard input</a></dt>

<dd>
<p>Currently, there is no support for providing standard input for the started external process.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Martin Senger &#60;martin.senger@gmail.com&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2013 by Martin Senger, CBRC-KAUST (Computational Biology Research Center - King Abdullah University of Science and Technology) All Rights Reserved.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>

<!-- end doc -->

</body></html>
